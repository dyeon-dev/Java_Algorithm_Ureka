# 자바
### 정수형
- int : 4byte 32bit <= 기본타입
- long : 8byte 64bit

### 실수형 
- float : 4byte 32bit 
- double : 8byte 64bit <= 기본타입

기본타입 - char, int, long ...

참조타입 - 배열타입, 열거타입, 클래스, 인터페이스

<br />


### 1. continue, break
- `break` : 해당 조건문 블록과 그 밖의 반복분 자체를 탈출
- `continue` : 해당 조건문 블록을 탈출하여 아래 명령문을 실행하지 않고, 다음 반복문 실행 절차를 수행


### 2. 접근제한자
- `public`: 모든 접근 허용. 클래스, 필드, 생성자, 메서드에서 사용 가능 
- `private` : 현재 객체 안에서만 허용. 필드, 생성자, 메서드에서 사용 가능


### 3. final
- final 필드는 초기값이 저장되면 최종적인 값이 되어서 중간에 바꿀 수 없다.
- 클래스 접근 제한자인 final을 붙여 클래스를 선언하면 하위 클래스를 가질 수 없는(다른 클래스가 상속할 수 없는) final class가 된다.


### 4. static
- `static`으로 선언된 변수, 메서드, 블록은 인스턴스화된 객체와 관계없이 클래스 자체에 속한다. 
이는 클래스의 모든 인스턴스가 동일한 `static` 멤버를 공유한다는 것을 의미
- 정적 변수 : 클래스에 속하는 변수, 클래스의 모든 인스턴스가 공유 
    ```
    static int a=0;
    ```
- 클래스 메서드(정적 메서드): static을 붙여 선언한 메서드. 인스턴스 변수나 메서드에 접근 불가 
    ```
    public class MyClass {
        static void staticMethod() {
            System.out.println("This is a static method.");
        }
    }
    ```
- 인스턴스 메서드(비정적 메서드): static을 붙이고 선언하지 않은 메서드. 그 클래스형의 개별 인스턴스에 속한다. 

### 5. 상속, 다형성
- 상속성: 새로운 클래스를 정의할 때 다른 클래스에서 정의한 것을 그대로 가져와 정의하는 것
    ```
    public class 자식클래스 extends 부모클래스 {}
    ```
- 다형성: 사용법은 동일하지만 실행결과가 다양하게 나오는 성질 
    - 다형성 구현을 위해 자동 타입 변환과 메소드 재정의 필요 
    - 메소드 오버라이딩 
    ```
    a = new Dog();
    b = new Cat();
    Animal x  = a;
    Animal x = b; 
    ```
### 6. this
- 객체 내부에서 인스턴스 멤버에 접근하기 위해 사용
- 인스턴스 필드임을 강조하조자 할때 사용
- 지역변수와 멤버변수를 구분할 때 사용
- this는 생성자로 생성한 객체 자신을 가리키는 참조변수. 객체의 주소가 저장
- this 변수: 객체 내부에서 자신의 주소를 가지는 기본제공 내장변수
- this() 메서드 호출: 생성자를 호출하는 코드. 생성자내부에서만 첫째줄에 사용가능
    ```
    public class MyClass {
        private int value;

        public MyClass(int value) {
            this.value = value; // 인스턴스 변수에 매개변수 값을 할당
        }
    }
    ```
### 7. 1차원, 2차원 배열
**1차원** 
- int[] arr; // 변수 선언(변수만 생성, 배열 객체는 안만듦)
- int arr[]; // 변수 선언 
- int[] arr = {1,2,3}; // 변수선언, 초기값 할당. 생성된 변수에 사용 불가
    - arr={4,5,6} // 컴파일 에러
- int[] arr = new int[] {1,2,3}; // 배열 변수를 선언한 시점과 값 목록이 대입되는 시점이 다르다면 new 타입 붙여줌. 선언, 할당 시 모두 사용 가능
    - arr={4,5,6} // 할당 가능 
    - arr = new int[3]{4,5,6} // 오류 
    
**2차원**
- int arr[][] = new int[2][3]; 
- int[][] arr2 = new int[][] { {1,2,3}, {4,5,6} }


### 8. String 클래스의 주요메서드
> String API (메서드)

String: Immutable Object(블변 객체) => 모든 변경 메서드들은 변경한 결과를 되돌려준다. 문자열 원본은 변하지 않는다. String, Integer 등 기본타입의 Wrapper 클래스

- `charAt(순번)` : char 추출
- `length()`: 길이
- `substring(순번)`
- `split(",")` : , 기준으로 문자열 나누어 반환 


### 9. String 객체의 비교 결과 (==, equals)
- `==` : 메모리 번지(stack) 비교
- `equals` : 문자열의 실제 내용 비교 
```
new: 사용할 공간을 새롭게 배정하여 주소가 다름
String n1 = "a"; // 메서드영역에 같은 문자열 공유
String n2 = "a"; // 메서드영역에 같은 문자열 공유
Sysout(n1==n2) // true
String n3 = new String("a"); // 힙에 따로 생성
String n4 = new String("a"); // 힙에 따로 생성
Sysout(n3==n4) // false
```
--- 

# 알고리즘
### 1. 시간복잡도
실행에 필요한 시간을 평가한 것

>O(1) < O(log(n)) < O(n) < O(nlog(n)) < O(n^2) < O(n^3) < O(n^k) < O(2^n)

### 2. 스택, 큐
- `스택`(LIFO) : push, pop, peek
    - Stack mystack = new Stack();
- `큐`(FIFO) : add(Enqueue), peek, poll(Dequeue), remove
    - front(데이터 나오는쪽), rear(데이터 넣는쪽)
    - Queue queue = new LinkedList(); // 큐같은 경우는 인터페이스만 제공하고 있으므로 링크드리스트나 배열리스트로 인스턴스를 만들어야됨

### 3. 연결 리스트
**List** : 자료형의 크기가 가변하는 상황이라면 List 사용. 
- `LinkedList`
    - 중간에 데이터 삽입 시 주소 값만 변경해주므로 ArrayList보다 빠른 처리.   
    - 검색 시 데이터를 순차적으로 각 노드에 접근해야 하기 때문에 ArrayList보다 느림 
- `ArrayList` 
    - 데이터를 순차적으로 추가, 삭제 시 빠른 처리. 배열의 중간에 객체를 추가, 삭제 시에 데이터 이동 발생하여 비효율적. 
    - 검색 시 빠른 속도
- 값만 저장 ( ***Collection*** )
    
    ***List***
    
    - 순서를 유지하고 저장
    - 중복 저장 가능
    - ArrayList, Vector, LinkedList
    
    ***Set***
    
    - 순서를 유지하지 않고 저장
    - 중복 저장 안됨
    - HashSet, TreeSet


### 4. 재귀함수
자기 자신을 호출하고 호출된 함수 스택에 저장, 호출 완료 시 스택에서 삭제

>잘못쓰면?
- 무한 반복
- 높은 메모리 사용
- 복잡한 디버깅
> 올바른 사용법
- **명확한 기본 부분 정의**: 기본 부분은 명확하고 정확해야 합니다. 이를 통해 재귀 호출이 반드시 종료되도록 해야 합니다.
- **문제의 작은 단위로 분할**: 재귀 호출을 통해 문제를 작은 단위로 분할하여 해결할 수 있도록 해야 합니다.
- **메모이제이션(Memoization) 사용**: 동일한 문제를 여러 번 계산하지 않도록 메모이제이션을 사용하여 효율성을 높일 수 있습니다. 이는 특히 피보나치 수열과 같은 문제에서 유용합니다.
- **반복문으로 대체 가능한 경우 고려**: 일부 문제는 재귀보다 반복문을 사용하는 것이 더 효율적일 수 있습니다. 특히, 깊은 재귀 호출이 필요하지 않은 경우 반복문을 사용하는 것이 더 나은 선택일 수 있습니다.


### 5. 순열, 조합, 부분집합
- 순열
    ```
    for (int i = 1; i <= n; i++) {
            if (visited[i]==false) {
                visited[i] = true;			 
                arr[cnt] = i;
                permutation(cnt + 1); // 재귀를 사용 
                visited[i] = false;
            }
        }
    ```

- 조합
    ```
    for (int i = start; i <= n; i++) {
            arr[cnt] = i;
            combination(cnt + 1, i + 1); // 오름차순으로 구하면 중복 체크하지 않아도 됨
        }
    ```

    <details>
    <summary>손코딩 ..</summary>
    <div markdown="1">
    
    ### c(0,0) 호출 시작 
#### cnt=0, statrt=0
i=0일 때, 
- arr[0]=0
- c(1,1) 호출 시 
    - cnt=1, start=1 / 이 시점에 배열 상태 arr = [0,0,0]
    - i=1일 때,
        - arr[1]=1
        - c(2,2) 호출
            - cnt=2, start=2 / 이 시점에 배열 상태 arr = [0,1,0]
                - i=2일 때
                    - arr[2]=2
                    - c(3,3) 호출 (조건 충족)
                        - cnt=3, start=3 / 이 시점에 배열 상태 = [0,1,2]
                        - cnt==r 이므로 출력 [0,1,2]
                        ---
                        백트래킹 및 다음 반복 - c(2,2)로 돌아가고 다음 i 실행
                - i=3일 때
                    - arr[2]=3
                    - c(3,4) 호출 (조건 충족)
                        - cnt==r이므로 출력 [0,1,3]
                        ---
                        백트래킹 및 다음 반복 - c(2,2)로 돌아가고 다음 i 실행
                - i=4일 때
                    - arr[2]=4
                    - c(3,5) 호출 (조건 충족)
                        - cnt==r이므로 출력 [0,1,4]        
                ---
                백트래킹 및 다음 반복 - c(1,1)로 돌아가고 다음 i 실행
    
    - i=2일 때,
        - arr[1]=2
        - c(2,3) 호출
            - cnt=2, start=3 / 이 시점에 배열 상태 arr= [0,2,0]
                - i=3일 때
                    - arr[2]=3
                    - c(3,4) 호출 (조건 충족)
                        - cnt==r이므로 출력 [0,2,3]
                        ---
                        백트래킹 및 다음 반복 - c(2,3)으로 돌아가고 다음 i 실행
                - i=4일 때
                    - arr[2]=4
                    - c(3,5) 호출 (조건 충족)
                        - cnt==r이므로 출력 [0,2,4]
                ---
                백트래킹 및 다음 반복 - c(1,1)으로 돌아가고 다음 i 실행

    - i=3일 때,
        - arr[1]=3
        - c(2,4) 호출 
            - cnt=2, start=4 / 이 시점에 배열 상태 arr = [0,3,0]
                - i=3일 때
                    - arr[2]=4
                    - c(3,5) 호출 (조건 충족)
                        - cnt==r이므로 출력 [0,3,4]
    
    ---
    백트래킹 및 다음 반복 - c(0,0)로 돌아가고 다음 i 실행
#### cnt=0, start=1
i=1일 때,
- arr[0]=1
- c(1,2)
    - cnt=1, start=2 / 이 시점에서 배열 상태 arr = [1,0,0]
        - i=2일 때, 
            - arr[1]=2
            - c(2,3) 호출
                - cnt=2, start=3 / 이 시점에서 배열 상태 arr = [1,2,0]
                - i=3일 떼
                        - arr[2]=3
                        - c(3,4) 호출 (조건 충족)
                            - cnt==r이므로 출력 [1,2,3]
                            ---
                            백트래킹 및 다음 반복 - c(2,3)으로 돌아가고 다음 i 실행
                    - i=4일 떼
                        - arr[2]=4
                        - c(3,5) 호출 (조건 충족)
                            - cnt==r이므로 출력 [1,2,4]
                ---
                백트래킹 및 다음 반복 - c(1,2)로 돌아가고 다음 i 실행    
        - i=3일 떼,
            - arr[1]=3
            - c(2,4) 호출
                - cnt=2, start=3 / 이 시점에서 배열 상태 arr = [1,3,0]
                    - i=4일 때
                        -  arr[2]=4
                        - c(3,5) 호출 (조건 충족)
                            - cnt==r이므로 출력 [1,3,4]
        ---
        백트래킹 및 다음 반복 - c(0,0)으로 돌아가고 다음 i 실행
#### cnt=0, start=2
i=2일 때,
- arr[0]=2
- c(1,3) 호출
    - cnt=1, start=3 / 이 시점에서 배열 상태 arr = [2,0,0]
        - i=3일 때,
            - arr[1]=3
            - c(2,4) 호출
                - cnt=2, start=3 / 이 시점에서 배열 상태 arr = [2,3,0]
                    - i=4일 때
                        - arr[2]=4
                        - c(3,5) 호출 (조건 충족)
                            - cnt==r이므로 출력 [2,3,4]
        ---
        백트래킹 및 다음 반복 - c(0,0)으로 돌아가고 다음 i 실행
---
모든 반복문 실행 후 종료
    
    </div>
    </details>
    

- 부분집합 : 각각의 원소들을 부분집합에 포함시키거나 포함시키지 않는 두가지 경우의 수를 모든 원소에 적용한 것과 같고 따라서 총 개수는 2^n개
    ```
        isSelected[cnt] = true;
        subset(cnt+1);
        isSelected[cnt] = false;
        subset(cnt+1);
    ```

### 6. 그래프, 트리
- **노드**: 데이터
- **엣지( 간선 )** : ***참조***
- **루트** : ***트리의 가장 윗부분***에 위치하는 노드를 루트라고 한다
- **리프** : ***트리의 가장 아랫부분***에 위치하는 노드를 리프라고 한다 ( 자식이 없는 노드 )
- **안쪽 노드** : 리프를 제외한 ***나머지 노드***
- **리프** : 어떤 노드에서 ***가지로 연결된 아래 쪽 노드***를 자식이라고 한다
- **부모 노드** : 어떤 노드에서 가지로 ***연결된 바로 위쪽 노드***
- **형제 노드** : ***부모가 같은 노드***를 형제라고 한다
- **조상 노드** : 어떤 노드에서 ***위쪽으로 뻗어 나간 모든 노드***를 조상이라고 한다
- **자손(자식) 노드** : 어떤 노드에서 ***아래쪽으로 뻗어 나간 모든 노드***를 자손이라고 한다
- **⭐ 레벨(깊이) 노드** : 루트로부터 ***얼마나 떨어져 있는지를 나타낸 값***을 레벨이라고 한다
    - ex) 루트 : 0레벨 , 가지가 하나씩 아래로 뻗어나갈 때마다 레벨이 1씩 증가
- **차수** : ***노드가 갖는 자식의 수***를 차수라 한다
- **높이** : 루트에서 가장 멀리 떨어진 리프까지의 거리 ( ***리프 레벨의 최대값*** ) 를 높이라 한다


### 7. BFS, DFS
- BFS : 하나 노드 방문 후 인접한 모든 노드 우선 방문. 두 노드 사이 최단 경로 구할 때 자주 사용. 큐
- DFS : 하나 노드 방문 후 그 노드의 모든 자식 노드 우선 방문. BFS보다 검색 느림. 스택, 재귀함수 사용 ex)백트래킹

### 투포인터, 슬라이딩 윈도우
- 투포인터: 시작인덱스, 종료인덱스를 투 포인터로 지정하여 접근

특정한 합을 가지는 부분 연속 수열 찾기

(정렬되어있다면)

S 증가 -> 합이 작아짐 S-V

E 증가 -> 합이 커짐 S+V

- 슬라이딩 윈도우: 크기를 지정하여 일정 범위 안에서 최솟값을 구하는 문제 

### 8. 정렬 알고리즘

|종류|특징|평균 시간복잡도|
|------|---|---|
|버블 정렬|인접한 두 수를 비교해 정렬|O(n^2)|
|선택 정렬|정렬되지 않은 배열에서 최솟값을 선택해 정렬|O(n^2)|
|삽입 정렬|정렬된 배열에 탐색중인 요소 삽입, 연결리스트 사용|O(n^2)|
|합병 정렬|- 분할 정복 기반 알고리즘 </br> - 배열을 1 이하 크기로 분할한 후 합병 과정에서 정렬|O(nlogn)|
|퀵 정렬|- 분할 정복 기반 알고리즘 </br> - 피봇을 선택해 피봇보다 작은 수의 배열과 피봇보다 큰 수의 배열로 분할하며 정렬 </br> - 피봇에 따라 시간복잡도가 달라질 수 있음|O(nlogn) </br> 최대 O(n^2)|

### 9. 분할정복 알고리즘
둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀호출을 통해 계산하고, 전체 문제의 답을 계산한다. 

>특징
- 분할된 작은 문제는 원래 문제와 성격이 동일 -> 입력 크기만 작아짐
- 분할된 문제는 서로 독립적 (중복제거x) -> 순환적 분할 및 결과 결합 가능

>예시 O(nlogn)
- 병합 정렬 
- 퀵 정렬
- 이진 탐색 - 정렬된 데이터만 사용 가능 

### 10. 그리디 알고리즘 
현재 상태에서 최선의 선택을 하는 알고리즘

>예시
- 서로소집합(유니온파인드)
- 크루스칼 알고리즘
    - 1. 간선 데이터를 비용에 따라 오름차순으로 정렬
    - 2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
    
